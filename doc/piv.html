<?xml version="1.0" encoding="UTF-8"?>
<html>
<head>
<title>Pi V Library</title>
<link rel="stylesheet" type="text/css" href="./default.css" />
</head>

<body>

<nav>
<a href="piv.html"><img alt="Pi V Logo" src="piv_resources/logo.png" /></a>

<h3 class="nav-heading">
  <a href="containers.html">+ Containers</a>
</h3>

<h3 class="nav-heading">
  <a href="algorithms.html">+ Algorithms</a>
</h3>

<h3 class="nav-heading">
  <a id="current-page" href="piv.html">+ About</a>
</h3>
<hr class="nav-hr" />
<ul class="top-level-nav-ul">
  <li><a href="intro.html">Intro</a></li>
  <li><a href="piv.html#download">Download</a></li>
  <li><a href="index.html#test-123">Test 123</a></li>
  <li><a href="index.html#compatibitity">Compatibility</a>
    <ul class="nested-nav-ul">
      <li><a href="index.html#compatibility">C99, little endian</a></li>
      <li><a href="index.html#compatibility">BSD License</a></li>
      <li><a href="naming_conventions.txt">Naming Conventions</a></li>
    </ul>
  </li>
  <li><a href="#">Administrativa</a></li>
  <li><a href="#">Benchmarks</a></li>
</ul>


<h3 class="nav-heading">
  <a href="baselibrary.html">+ Memory Vectors</a>
</h3>

</nav>

<div id="main-content-width-div">

<div id="leaderboard">
<!--<img src="https://lh5.ggpht.com/NFYFP2H9CCP50vAQNLa7AtCj_mbbYmOzY978fZqd31oL5qOdvXgxU3KW8ek2VgvIOvTqWY0=w728" />
-->
</div>

<section id="abstract">
<h1>Pi V <span>(a data structure library for C]</span></h1>
<p>
The Pi V library provides generic data stuctures and algorithms,
plus memory management procedures, in C.
Its design is inspired by Alexander Stepanov's
<a href="http://stepanovpapers.com/BYTE_com.htm" target="_blank">STL</a>
and by functionality needed for the
<a href="#">Ad1</a>
compiler.
</p>

<p>Pointers and ranges are generalized to <em>memory vectors</em>,
transformation functions describe vector arithmetic in a data space,
and macros are used like C++ templates for pairing generic data types 
with different data structures and structure invarients.
Finally, (C++)--like interface function tables are generated for each
pairing for convenience.
</p>
<p>Containers, which are data structures with <em>rules and state</em>
for memory management, are called pies in Pi V.
The full variety of containers are listed in <a href="#table1">table 1</a>.
They are implemented in individual header files for complete compiler
parsing but are organized in five classes for human reading.
</p>
<p>
Most algorithms can be applied only to certain classes
of containers. For example piv_bsearch() has logarithmic complexity
guarantees only for array-like, block allocated, and ordered pair 
containers but the DO...FOR EACH idiom can be applied to any
container because they are all sequential.
A common memory allocator, the common vector interface, and this
collection of common algorithms are all provided in the
<a href="#">Pi V base library</a>.
</p>
<table id="table1">
<caption>Table 1: Listing of Containers in Pi V</caption>
<tr>
  <td rowspan="5">I. Random Access Structures</td>
  <td>pique</td>
  <td></td>
  <td>1D dynamic array</td>
</tr>
<tr>
  <td>pideque</td>
  <td></td>
  <td></td>
<tr>
  <td>pitwo</td>
  <td></td>
  <td>dynamic and static circular buffers</td>
</tr>
<tr>
  <td>pimat</td>
  <td></td>
  <td>fixed size 1D and 2D arrays</td>
</tr>
<tr>
  <td>pir_array</td>
  <td></td>
  <td>reverse of pique</td>
</tr>
<tr>
  <td rowspan="4">II. List Structures</td>
  <td>pifwd_list</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>pibid_list</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>pixor_list</td>
  <td></td>
  <td>uses 32 bit flag to indicate presense</td>
</tr>
<tr>
  <td>piskip_list</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td rowspan="5">III. Search Tree Structures</td>
  <td>pibinary_tree</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>pixor_tree</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>pinary_tree</td>
  <td></td>
  <td>a queue pointing into a linked list</td>
</tr>
<tr>
  <td>pibalanced_tree</td>
  <td></td>
  <td></td>
</td>
<tr>
  <td>pibuffer_tree</td>
  <td></td>
  <td></td>
</td>
<tr>
  <td rowspan="3">IV. String Data Varients</td>
  <td>piv_map</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>piv_multimap</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>piv_heap</td>
  <td></td>
  <td>binary tree structure but implemented on maybe a deque</td>
</tr>
<tr>
  <td rowspan="2">V. Ordered Pair Invarients</td>
  <td>piv_exptree</td>
  <td></td>
  <td>string headers grow to the left as structs</td>
</tr>
<tr>
  <td>piv_dictionary</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td colspan="4">
(1) LIFO or (2) FIFO | (3) zero allocated or (4) not | (5) (key, value) or (6) (key=value)
  </td>
</tr>
<tr>
  <td>pislice</td>
  <td></td>
  <td></td>
</tr>
</table>

<img src="./figures/blocked-structures.jpeg" alt="[block structures]" width="325px"/>
<img src="./figures/list-structures.jpeg" alt="[list structures]" width="300px"/>

<p>Common algorithms and a sort-of framework for easily using the "pie"
containers is declared in <a href="./piv_stdlib.html">pi_stdlib</a>.
This includes a custom memory allocator, macros and definitions for vector
iterators and range, and implementations of 
<a href="#">pi_mergesort()</a>,
<a href="#">pi_quicksort()</a>,
<a href="#">pi_radixsort()</a>,
<a href="#">pi_binarysearch()</a>, etc.
</p>

<p>The library is licensed under the GLPL version 2.1.
It is compatible with C99 and C11, and even ANSI C89 if your system
has <span>&lt;stdint.h&gt;</span> or you include this portable
equivalent, <a href="../pstdint.h">pstdint.h</a> written by Paul Hsieh.
Little Endian.
</p>

<section>
<h1>Impetus for Pi-V</h1>
<p></p>
</section>
<br />



<p>
The 5 containers are each defined and implemented in single files,
<span><a href="./pique.h">pique.h</a></span>,
<span><a href="./pitwo.h">pitwo.h</a></span>,
<span><a href="./piflist.h">piflist.h</a></span>,
<span><a href="./pixlist.h">pixlist.h</a></span>, and
<span><a href="./pistack.h">pistack.h</a></span>, while
algorithms and memory vectors are defined in their own library
with two files <span><a href="./pi_stdlib.h">pi_stdlib.h</a></span>
and <span><a href="./pi_stdlib.c">pi_stdlib.c</a></span>.
All are released under the GLPL version 2.1.
</p>
<table width="700px">
<tr>
  <th><a href="pique.html">pique</a></th>
  <td>dynamically sized arrays with constant time
      <span>pop_front()</span>, <span>pop_back()</span>, and
      amortized constant time <span>push_back()</span>.
</tr>
<tr>
  <th><a href="pitwo.html">pitwo</a></th>
  <td>fixed size circular buffers with amortized constant
      <span>push_front()</span>.</td> 
</tr>
<tr>
  <th><a href="piflist.html">piflist</a></th>
  <td>forward lists with constant time <span>pop_front()</span>,
      <span>push_front()</span>, and <span>push_back()</span></td>
</tr>
<tr>
  <th><a href="pixlist.html">pixlist</a></th>
  <td></td>
</tr>
<tr>
  <th><a href="pistack.html">pistack</a></th>
  <td>a blocked array structure with constant time <span>push</span>
      and <span>pop</span> operations and log(N) <span>insert()</span>/
      <span>delete()</span>.</td>
</tr>
<tr>
  <th><a href="pi_stdlib.html">pi_stdlib</a></th>
  <td><span>pi_bsearch()</span>, <span>pi_qsort()</span>,
      <span>pi_alloc()</span>, <span>DO()...FOR_EACH()</span>, etc.</td>
</tr>
</table>
</section>

<section id="compile-and-test">
<hr/>
<h1>Compile and Test</h1>
<p>compile object file instructions. 3 files. gcc command.
instructions for C89 without stdint.h. finally test program.
</p>
<p>To compile a program using Pi-V you need pi_stdlib.h,
pique.h, pi_stdlib.c (or object code), and any of the other
4 header files if you need that particular data structure.
In your program it is sufficient to include only the header file for
the data structure you are using. When invoking the compiler,
don't forget to compile and/or link against pi_stdlib.c.
</p>
<p>
Copy the program below and place it in a directory with
<a href="../pi_stdlib.h">pi_stdlib.h</a>,
<a href="../pique.h">pique.h</a>, and
<a href="../pi_stdlib.c">pi_stdlib.c</a>. Then compile with
$<span>gcc test_program.c pi_stdlib.c</span> and run with
$<span>./a.out</span> on Linux.

<pre style="float:left;">

#include &lt;stdio.h&gt;
#include "lor_vector.h"

   
int main() {
  lor_vector_t primes = LOR_VECTOR(int, NULL, NULL);
  lor_vector.push_back(&amp;primes, 2);
  lor_vector.push_back(&amp;primes, 3);
  printf("vector size = %d\n", lor_vector.size(&amp;primes));
}

</pre>
<pre style="float:left;">

#include &lt;stdio.h&gt;
#define LOR_VECTOR_NAMESPACE <b>vec</b>
#include "lor_vector.h"

int main() {
<b>vec</b>_t primes = LOR_VECTOR(int, NULL, NULL);
<b>vec</b>.push_back(&amp;primes, 2);
<b>vec</b>.push_back(&amp;primes, 3);
printf("vector size = %d\n", <b>vec</b>.size(&amp;primes));

}
</pre>
<div style="clear:left"></div>


<p>
Lor vector works with any data type, but the types' size must be known.
Consequently, you must register the data type when declaring a lor vector
container. This is done in the first parameter of the 
<span>LOR_VECTOR()</span> initialization macro.
</p>
<pre>

typedef struct item {
  ...
} item;

lor_vector_t price_list = LOR_VECTOR(item, NULL, NULL);

</pre>
<p>
For some structures, you may wish to have copy constructor and
destructor functions associated with them
(see <a href="#">some advatages of C++ object oriented programming</a>).
To be registered with a lor vector, the copy constructor function should have a
pointer parameter for the copy destination, a constant pointer parameter for the
source, and void return. A destructor function should have one pointer parameter.
For example,
</p>
<pre>

void item_copy_constructor(item* dest, const item* src) {
  ...
}

void item_destructor(item*) {
  ...
}

lor_vector_t price_list = LOR_VECTOR(item, item_copy_constructor, item_destructor); 

</pre>
</section>


<section id="limitations">
<hr/>
<h1>Limitations in Pi-V</h1>
<ol>
  <li>Pi-V might be too reliant on macros, which often makes debugging
      difficult and produces cryptic compiler errors. This can be partially
      attributed to C not offering templates and iterators like C++,
      and partially to me using text substitution to paper over deficiencies
      in my design for polymorphism between vector types.
      (i.e. be able to use INC() on all vector types, etc.)</li>
  <li>Anytime dynamic memory allocation is done, there is a chance for
      failure. C++, D, and other languages have mechanisms for handling
      this but Pi-V ... sort of encourages ignoring the problem. One thing
      you can do is use the ternary operator for error checking pushes:
<pre>
(ptr = pique.push_back(&amp;prime_numbers)) ? (*ptr = 17) : (printf("error"));
</pre>
      maybe a macro? ironically.
  </li>
  <li>The pitwo data structure is not able to use its full capacity in my
      implementation, because having zero elements is indistiguishable
      from having 2^n elements.
  </li>
  <li>The effectiveness of pi_malloc...</li>
</ol>

<p>Listing specific limitations is easy, but perhaps the greatest limitation
is the author's lurking opinions.
It is possible this library is more about me being smitten with C but
lusting after features it doesn't have, more than about being useful to anyone.
I think indexing should be from 1 to N and pointers should point from the right.
Further, if you are having memory allocation errors,
then might as well give up with an out of bounds error instead of
trying to make a complicated runtime to deal with it.
Finally, I consider item 3 on the list to be intentional for when
I eventually write my grandoise and narcissistic string library.
Its not a mistake, its intentional. Promise.
</p>
</section>

</div><!-- main-content-width-div -->

<footer>
<hr />
Copyright (c) Ben Lorenzetti 2017<br />
Redistribution and use is permitted under the terms of the 3-clause
<a href="./FreeBSD_Documentation_License.txt">FreeBSD Documentation License</a>.
</footer>

</body>
</html>
